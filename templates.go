package main; var loadedTempl = map[string]string{ "main.tmpl" : "package main\nimport (\n    \"log\"\n    \"net/http\"\n    \"github.com/gorilla/mux\"\n)\n\nfunc main() {\n    router := mux.NewRouter()\n    logger := NewLogger(\"info\")\n\n    {{range .Routes}}\n         router.HandleFunc(\"{{.Path}}\", {{.OpId}}).Methods(\"{{.Method}}\")\n    {{end}}\n    logger.Infof(\"Server started on {{.Host}}\")\n    log.Fatal(http.ListenAndServe(\"{{.Host}}\", router))\n}", "route.tmpl" : "package main\nimport (\n    \"net/http\"\n)\n\nfunc {{.OpId}} (w http.ResponseWriter, r *http.Request) {\n    logger := NewLogger(\"info\")\n    s:= ParseRules(\"{{.RuleFile}}\")\n    if err:=ProcessRule(w,r,s.Rules, \"{{.OpId}}\"); err!=nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        logger.Errorf(\"Error while processing opid: {{.OpId}}\" )\n        return\n    }\n}\n", "MockServer.go" : "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\ntype MockServer struct {\n\tRules []Rule\n}\n\ntype Rule struct {\n\tOpId       string\n\tTimeout    string\n\tMethod     string\n\tArgs       []Argument\n\tStatusCode int\n\tResponse   interface{}\n}\n\ntype Argument struct {\n\tArgType string\n\tArgName string\n\tBody    interface{}\n}\n\nfunc ParseRules(filename string) *MockServer {\n\tdata, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar mock MockServer\n\terr = json.Unmarshal(data, &mock)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn &mock\n}\n", "log.go" : "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\nconst (\n\tinfoLevel = 1\n\terrLevel  = 2\n)\n\ntype Log struct {\n\tlevel int\n}\n\nfunc NewLogger(logLevel string) *Log {\n\tif logLevel == \"err\" {\n\t\treturn &Log{1}\n\t}\n\tif logLevel == \"info\" {\n\t\treturn &Log{2}\n\t}\n\n\treturn &Log{0}\n}\n\nfunc (l *Log) Infof(format string, args ...interface{}) {\n\tif l.level >= infoLevel {\n\t\tlog.SetPrefix(\"INFO: \")\n\t\tlog.SetOutput(os.Stdout)\n\t\tlog.Printf(format, args...)\n\t}\n}\n\nfunc (l *Log) Errorf(format string, args ...interface{}) {\n\tif l.level >= errLevel {\n\t\tlog.SetPrefix(\"ERROR: \")\n\t\tlog.SetOutput(os.Stderr)\n\t\tlog.Printf(format, args...)\n\t}\n}\n\nfunc (l *Log) Fatalf(format string, args ...interface{}) {\n\tlog.SetPrefix(\"FATAL: \")\n\tlog.SetOutput(os.Stderr)\n\tlog.Fatalf(format, args...)\n}\n", "processRoute.go" : "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n)\n\nfunc ProcessRule(w http.ResponseWriter, r *http.Request, rules []Rule, opId string) error {\n\tbody := readBody(r)\n\tfor _, rule := range rules {\n\t\tif rule.OpId == opId {\n\t\t\tfound := false\n\t\t\tfor _, arg := range rule.Args {\n\t\t\t\tfmt.Println(rule)\n\t\t\t\tswitch argType := arg.ArgType; argType {\n\t\t\t\tcase \"query\":\n\t\t\t\t\tif exists := CheckQueryParam(r, arg); exists == true {\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\tcase \"form\":\n\t\t\t\t\tif exists := CheckFormParam(r, arg); exists == true {\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\tcase \"JSON\":\n\t\t\t\t\tif exists := CheckJSONParam(r, arg, body); exists == true {\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\tcase \"path\":\n\t\t\t\t\tif exists := CheckPathParam(r, arg); exists == true {\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn fmt.Errorf(\"Invalid arg type\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif found == true {\n\n\t\t\t\tdata, err := json.Marshal(rule.Response)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"Processing body: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tif d, err := time.ParseDuration(rule.Timeout); err == nil {\n\t\t\t\t\ttime.Sleep(d)\n\t\t\t\t}\n\n\t\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t\tw.WriteHeader(rule.StatusCode)\n\t\t\t\tw.Write(data)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\treturn fmt.Errorf(\"no rule found\")\n}\n\nfunc CheckQueryParam(r *http.Request, arg Argument) bool {\n\tparam := r.URL.Query().Get(arg.ArgName)\n\treturn param == arg.Body\n}\n\nfunc CheckPathParam(r *http.Request, arg Argument) bool {\n\tvars := mux.Vars(r)\n\treturn vars[arg.ArgName] == arg.Body\n}\n\nfunc CheckFormParam(r *http.Request, arg Argument) bool {\n\tr.ParseForm()\n\tparam := r.FormValue(arg.ArgName)\n\treturn param == arg.Body\n}\n\nfunc CheckJSONParam(r *http.Request, arg Argument, body []byte) bool {\n\n\tlogger := NewLogger(\"info\")\n\tvar bodyReq interface{}\n\tif err := json.Unmarshal(body, &bodyReq); err != nil {\n\t\tlogger.Errorf(\"Error while unmarshaling body %v\", err)\n\t\treturn false\n\t}\n\treturn reflect.DeepEqual(bodyReq, arg.Body)\n}\n\nfunc readBody(r *http.Request) []byte {\n\tlogger := NewLogger(\"info\")\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error while reading body %v\", err)\n\t\treturn nil\n\t}\n\treturn body\n}\n"}